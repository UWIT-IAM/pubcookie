From fmf@cac.washington.edu Fri Feb 12 15:56:18 1999
Date: Fri, 12 Feb 1999 10:38:08 -0800
From: Frank Fujimoto <fmf@cac.washington.edu>
To: Steve Willey <willey@cac.washington.edu>
Subject: pubcookie

ah, the reason it was having problems was because i tested for
subrequests, but not internal redirects (and it even said 'internal
redirect', duh).  it showed up last nite because i was trying to get
access to xxx/ which implicitly maps to xxx/index.html

the patch is to make sure i'm using the main request of the original
request, not any redirects.  in addition, i've changed auth_failed to
return the uri of the original request, not an internal redirect.  this
way if i access xxx/ which internally redirects to xxx/index.html, then
when i get sent to pcookiel1 and the back, the url still says xxx/
(before it would say xxx/index.html)

also - how about changing the logout page so it checks for
$HTTP_REFERER and makes a link to that?  or, if people access it with
something like:

    https://weblogin.washington.edu/login/logout/?http://www.washington.edu/

then it has a link to the url in $QUERY_STRING?

anyway, diffs below, and this version is on wwwdev  -fmf


*** mod_pubcookie.c.old	Fri Feb 12 10:35:21 1999
--- mod_pubcookie.c	Fri Feb 12 10:27:35 1999
***************
*** 85,100 ****
  
  }
  
  int blank_cookie(request_rec *r, char *name) {
    const char *cookie_header; 
    char *cookie;
    char *ptr;
!   request_rec *mr;
    char *c2;
  
-   mr = r;
-   while (mr->main)
-     mr = mr->main;
    /* If we've stashed the cookie, we know it's already blanked */
  #ifdef APACHE1_2
    if(table_get(mr->notes, name) ||
--- 85,111 ----
  
  }
  
+ request_rec *main_rrec (request_rec *r) {
+     request_rec *mr = r;
+ 
+     for (;;) {
+ 	while (mr->main)
+ 	    mr = mr->main;
+ 	while (mr->prev)
+ 	    mr = mr->prev;
+ 	if (! mr->main)
+ 	    break;
+     }
+     return mr;
+ }
+ 
  int blank_cookie(request_rec *r, char *name) {
    const char *cookie_header; 
    char *cookie;
    char *ptr;
!   request_rec *mr = main_rrec (r);
    char *c2;
  
    /* If we've stashed the cookie, we know it's already blanked */
  #ifdef APACHE1_2
    if(table_get(mr->notes, name) ||
***************
*** 166,171 ****
--- 177,183 ----
    char			*refresh_e;
    pubcookie_server_rec 	*scfg;
    pubcookie_rec 	*cfg;
+   request_rec		*mr = main_rrec (r);
  
  #ifdef APACHE1_2
    cfg = (pubcookie_rec *) get_module_config(r->per_dir_config, 
***************
*** 193,199 ****
  	  PBC_VERSION, 
  	  r->method, 
  	  r->server->server_hostname, 
! 	  r->uri,
  	  (cfg->force_reauth ? cfg->force_reauth : PBC_NO_FORCE_REAUTH));
  
    if ( cfg->force_reauth )
--- 205,211 ----
  	  PBC_VERSION, 
  	  r->method, 
  	  r->server->server_hostname, 
! 	  mr->uri,
  	  (cfg->force_reauth ? cfg->force_reauth : PBC_NO_FORCE_REAUTH));
  
    if ( cfg->force_reauth )
***************
*** 284,295 ****
  char *get_cookie(request_rec *r, char *name) {
    const char *cookie_header; 
    char *cookie, *ptr;
!   request_rec *mr;
  
    /* get cookies */
-   mr = r;
-   while (mr->main)
-     mr = mr->main;
  #ifdef APACHE1_2
    if( (cookie_header = table_get(mr->notes, name)) )
      return pstrdup(r->pool, cookie_header);
--- 296,304 ----
  char *get_cookie(request_rec *r, char *name) {
    const char *cookie_header; 
    char *cookie, *ptr;
!   request_rec *mr = main_rrec (r);
  
    /* get cookies */
  #ifdef APACHE1_2
    if( (cookie_header = table_get(mr->notes, name)) )
      return pstrdup(r->pool, cookie_header);

