/*
    Copyright 1999-2002, University of Washington.  All rights reserved.
     ____        _                     _    _
    |  _ \ _   _| |__   ___ ___   ___ | | _(_) ___
    | |_) | | | | '_ \ / __/ _ \ / _ \| |/ / |/ _ \
    |  __/| |_| | |_) | (_| (_) | (_) |   <| |  __/
    |_|    \__,_|_.__/ \___\___/ \___/|_|\_\_|\___|

    Created by the Pubcookie Team

    Comments and suggestions: pubcookie-dev@u.washington.edu
    Pubcookie on the Web: http://www.pubcookie.org/

    this is installation documentation for the login sever
 */

/*
    $Id: INSTALL.login.txt,v 1.22 2002-08-16 20:06:42 dors Exp $
 */


1. Introduction

The Pubcookie login server has two primary functions: to authenticate
users and to issue authentication tokens (granting cookies) consumed by
Pubcookie-enabled target application servers.  Authentication occurs
either by checking user-provided credentials via a backend authentication
service (Kerberos, SecurID, ...) or by verifying a token that was created
on a previous visit to the login server.  Example code to interface to an
authentication system is provided.

2. Implementation

The Pubcookie login server uses a CGI program to handle all HTTP
requests.  This CGI program, hereafter referred to as "the login cgi"
or "index.cgi", is compiled from C and is the central Pubcookie
component.  The login cgi displays the web page where users are asked
to enter authentication credentials as well as other web pages that
display error messages.

Due to the important nature of the Pubcookie login server, the only other
services that should be run on the same system are those which receive an
equally high level of scrutiny for security.  As deployed at the
University of Washington, the Pubcookie login server is powered by the
Apache web server software. Other web server software which supports CGI
and SSL should also work, but this supposition has not been tested.

3. Authentication services

The login cgi has a very simple interface for talking to backend
authentication services. 

Most sites will want to use the "basic" login flavor, which supports
username/paassword single-sign-on authentication.  (Currently no other
flavors exist!)

The basic login flavor supports many different verifiers.  Some of the
ones shipped with pubcookie as of this writing are:

* kerberos_v5: check username/password against a Kerberos 5 KDC.
* ldap: check username/password against an LDAP server.
* shadow: check username/password against /etc/shadow
* alwaystrue: allow any username/password combination to authenticate.

You can set which verifier to be used with the "basic_verifier"
configuration parameter (see "Run-time configuration").  Some
verifiers will allow or require further customization; see the section
referring to that verifier.

4. Apache Configuration (assuming you are using Apache for the login server)

4.1. Choosing the location of your login page

Depending on your installation environment you may choose to install the
login server in a number of configurations.  Two general models are
presented here with any necessary Apache configuration directives.

Specifying the Login URL as a Directory

For a clean looking login URL you can install the login server to be the
default file in a directory.  The default filename, index.cgi, is a common
name for a cgi file that would be executed when only directory URL is
specified.

At the University of Washington we use:

https://weblogin.washington.edu/  

as the login server URL; it's very simple for users to identify in the 
browser's URL field.  

The Apache config directive 'DirectoryIndex' tells Apache it how to
handle requests for directories.  See
http://httpd.apache.org/docs/mod/mod_dir.html#directoryindex for more
information.  When a request is made for a directory Apache will
choose the first file it finds in the DirectoryIndex list.

Our DirectoryIndex line looks something like:

DirectoryIndex index.html index.cgi

If this is the configuration you choose, make sure there isn't an
index.html file in the same directory as the index.cgi binary.

Explicit Specification of Login CGI

The login CGI is not name dependant and can be deployed as index.cgi,
login.cgi, or some other CGI file if you like.  In can also be put in any
subdirectory you wish.

Your login server's URL could be something like:

  https://www.myuniversity.edu/cgi-bin/login.cgi

Some sites may do this avoid the confusion with the default index page.

Depending how you want to configure things with Apache or which ever Web
server you want to use for the login server, your login server URL could
be something like:

  https://www.myuniversity.edu/login

where /login is mapped to the CGI program (index.cgi or whatever you
rename it to).

The default login server and login URI are specified as "login_host"
and "login_uri" in pubcookie configuration file.  (Individual
applications may override what login server they refer to with the
PubCookieLogin directive in their apache configuration file.)

4.2. Apache configuration directive you might have to tweak

Apache needs to know how to identify and handle cgi scripts.  Some
distributions of Apache will hav the cgi handler disabled, you will
want to make sure the following line is in your httpd.conf and not 
commented out.

AddHandler cgi-script .cgi

5. Build the Pubcookie login server

This has been made easier with autoconf. (Thanks Jon Miner, University 
of Wisconsin!) To build a barebones login server, run:

$ ./configure --enable-login --disable-apache
$ make
$ make install

This sequence will build and install the index.cgi, keyserver, and
keyclient binaries, using the default directory prefix
(/usr/local/pubcookie, henceforth called {PUBCOOKIE_DIR}) and "alwaystrue"
verifier.

To build the login server with other verifiers enabled (e.g. Kerberos 5, 
LDAP, or Shadow) look at the configure options and adjust accordingly:

$ ./configure --help

6. Run-time configuration:

Most configuration of the login server can be done at run-time via
Pubcookie's "config" file. It is located at {PUBCOOKIE_DIR}/config and has
"attr: value" lines throughout.  A sample configuration file is included
as "config.sample".

Some of the more notable variables are:

debug (integer)   - Non-zero value enables debug logging.  The higher
                    the number, the more debugging output that is 
                    generated.
login_host        - the hostname of login server
login_uri         - the complete URI of the login cgi
enterprise_domain - the domain under which all hosts will live.  must be 
                    at least a second level domain (e.g. somewhere.edu)
basic_verifier    - the verifier to use for the "basic" flavor
keymgt_uri        - the location of the "keyserver" CGI.  See "Key
                    Management" below.

The following options should refer to the same files that your web
server uses for SSL.  At least one of 'ssl_ca_file' and 'ssl_ca_path'
should be specified.  

ssl_key_file - the location of the SSL key
ssl_cert_file - the location of the SSL certificate 

If your institution uses a single CA without any intermediate
certificates, set 'ssl_ca_file' to the path of the CA's certificate. If
your institution uses multiple CAs or intermediate certificates, you'll
need a directory ('ssl_ca_path') contain those certificates named via
their OpenSSL hashes.

ssl_ca_file - the location of a single CA
ssl_ca_path - a directory containing files named after their OpenSSL hash

See CONFIG.txt for a full list of attributes.

7. Localization

The design of the login cgi preceded consideration of external use of
Pubcookie, so there is much work to be done to improve flexibility and
make it less specific to the University of Washington.

However, preliminary work has been done with login templates
(specifying the look of each page the login CGI serves up) and the
run-time configuration file.  These pages should live in
{PUBCOOKIE_DIR}/login_templates.  We recommend you start with the
files in login_templates.generic/ and customize them as you see fit.

8. More configuration: User agent blocking via ok_browsers file

The {PUBCOOKIE_DIR}/ok_browsers file contains a list of acceptable
browsers.  The idea behind ok_browsers is to block browsers that
either have a known security flaw (i.e. don't forget cookies when they
should) or don't work with Pubcookie (i.e. Opera which doesn't do
domain level cookie scoping correctly).  IE and Netscape are the only
two browser families that are known to work with Pubcookie.

So far we've been too chicken to really use the 'ok_browsers'
functionality to block browsers that we know don't work.  For now our
ok_browsers has a single line: "Mozilla". Since both Netscape and IE
claim to be Mozilla that covers the only two browsers known to work
with Pubcookie. Proceed according to your own policy.

9. Key management

{PUBCOOKIE_DIR}/keys is the location of the keystore that the login
cgi uses.  The login cgi makes use of several different keys.

9.1 Generate or reuse keypairs for the login server

The pubcookie_login key and certificate are used to secure the "login
cookie" that maintains the single sign-on session with the login server.  
These files are kept exclusively on the login server. Note: you can reuse
your existing private key and SSL server certificate rather than 
generating a new keypair. 

$ openssl req -new -x509 -nodes -out /usr/local/pubcookie/keys/pubcookie_login.cert.<hostname> -newkey rsa:1024 -keyout /usr/local/pubcookie/keys/pubcookie_login.key.<hostname>

The corresponding config file attr are ssl_cert_file and ssl_key_file.

9.2 Generate granting keypair for authentication assertions

Next, the pubcookie_granting keypair is needed to secure authentication
assertions sent from login server to application servers, as represented
by the "granting cookie".  The key is kept exclusively on the login
server; the certificate must be distributed to every application server.

$ openssl req -new -x509 -nodes -out /usr/local/pubcookie/keys/pubcookie_granting.cert.<hostname> -newkey rsa:1024 -keyout /usr/local/pubcookie/keys/pubcookie_granting.key.<hostname>

The corresponding config file attr are granting_cert_file and
granting_key_file.

9.3 Configure keyserver on the login server

"keyserver" is a program that maintains DES keys.  Unfortunately, due
to subtleties in the key usage constraints, it is unable to run as a
CGI underneath a login server.  Instead, we recommend that it be run
from inetd.

Add a line like the following to the login server's inetd.conf:

2222    stream  tcp     nowait  root    /usr/local/pubcookie/bin/keyserver keyserver

where "/usr/local/pubcookie/bin/keyserver" is where the keyserver binary
is installed.  Make sure that your "pubcookie/config" file is
correctly configured.

If you are using xinetd, you should create a file named "keyserver" in
/etc/xinetd.d with the following contents:

---cut here---
# description: pubcookie keyserver
service keyserver
{
	type			= UNLISTED
	protocol		= tcp
	port			= 2222
	disable			= no
	socket_type		= stream
	wait			= no
	user			= root
	group			= tty
	server			= /usr/local/pubcookie/bin/keyserver
}
---cut here---

After adding this line, restart inetd.

9.3 Generate a DES key for the login server with keyclient

Now run keyclient to generate a DES key for the login server:

% /usr/local/pubcookie/bin/keyclient

This will cause the keyserver program to generate a new DES key for
the login server to use to provide confidentiality for the login
cookies.

9.4 Generating DES keys for the application servers with keyclient

Generating DES keys for the application servers is just as easy as
above---in fact, the exact same command works.

It is important that the application server's SSL certicate is signed
by the same certificate authority as is configured in the login
server's config file.

Remember that the application server will also need a correct 'config'
file.

*************************************************
   UPGRADING
*************************************************

* Maintaining DES key compatibility from hashed IP addresses

If you have an exisiting pubcookie installation using a shared DES key
with hashed IP addresses, you can upgrade your login server without 
generating new keys on every application server.

On the login server, in the .../pubcookie/keys/ directory, make a copy of
the master DES key (before hashing it to any IP address) for each application
server, named with the full hostname of the server.

For example, create

.../pubcookie/keys/oldappserver.somewhere.edu

containing the original DES keyfile.

The login server will use this key to encrypt data going to that application
server, and the application server can continue to use it's key (XOR'd with
it's IP address) to decrypt the data.

During the application server's next scheduled downtime, you can create a new
unique DES key for that application, as in 9.4 above.



*************************************************
   ADVANCED CONFIGURATION
*************************************************

* How do I configure multiple login servers?


* How do I configure multiple redundant application hosts?

*************************************************
   SECURITY CONSIDERATIONS
*************************************************

* The login server

don't run anything else on it: anyone who can add content
to the login server can steal all cookies

* Application servers

* Handling secrets

*************************************************
   OTHER STUFF
*************************************************

12. Old Tools That Might Be Handy for Debugging:

pbc_create - creates a pubcookie cookie, convenient for creating cookies 
ad hoc.  Arguments come in via stdin and the cookie is put out on stdout. 
Args are space delimited, and in order: user appsrvid appid type creds 
serial crypt_file cert_key_file.  Anything too big is just truncated, 
no support for defaults or anything like that.  See src for details.

pbc_verify - decrypts/verifies/displays pubcookie cookies, convenient for
'unbundling' a cookie and seeing what's inside.  The arguments come in on
the command line, the cookie comes in on stdid, and the contents are 
dumped to stdout.  The required argument is cookie_type and the optional 
arguments are encryption_key and cert_file.

As an example you can use these two programs to do things like:

# echo "willey appsrvid appid 1 2 23 /usr/local/pubcookie/c_key /usr/local/pubcookie/test.key" | ./pbc_create | ./pbc_verify 1 /usr/local/pubcookie/c_key /usr/local/pubcookie/test.cert

and get something like

user: willey
version: a5
type: 1
creds: 2
serial: 23
appsrvid: appsrvid
appid: appid
create_ts: 1006986719
last_ts: 1006986719

