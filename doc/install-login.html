<html>

<head>
<title>Pubcookie login cgi</title>
<link rel="stylesheet" href="pubcookie.css" type="text/css" title="pubcookie">
</head>

<body>

<h1>Pubcookie login cgi</h1>

<p><i>Included on this page:</i></p>

<ul>
<li><a href="#intro">Introduction</a></li>
<li><a href="#implementation">Implementation</a></li>
<li><a href="#authsvcs">Authentication Services</a></li>
<li><a href="#apacheconfig">Apache Configuration</a></li>
<li><a href="#build">Build the Pubcookie login server</a></li>
<li><a href="#runtime">Run-time Configuration</a></li>
<li><a href="#localization">Localization</a></li>
<li><a href="#moreconfig">More Configuration</a></li>
<li><a href="#keymgt">Key Management</a></li>
<li><a href="#logout">Logout Configuration</a></li>
<li><a href="#upgrading">Upgrading</a></li>  
<li><a href="#advconfig">Advanced Configuration</a></li>
<li><a href="#security">Security Considerations</a></li>
<li><a href="#oldtools">Old Debugging Tools</a></li>
</ul>

<h4><a name="intro">Introduction</a></h2>

<p>
The Pubcookie login server has two primary functions: to authenticate
users and to issue authentication tokens (granting cookies) consumed by
Pubcookie-enabled target application servers.  Authentication occurs
either by verifying user-provided credentials via a backend authentication
service (Kerberos, SecurID, ...) or by checking a token that was created
on a previous visit to the login server.  Example code to interface to an
authentication system is provided.
</p>

<h4><a name="implementation">Implementation</a></h4>

<p>
The Pubcookie login server uses a CGI program to handle all HTTP
requests.  This CGI program, hereafter referred to as "the login cgi"
or <tt>index.cgi</tt>, is compiled from C and is the central Pubcookie
component.  The login cgi displays the web page where users are asked
to enter authentication credentials as well as other web pages that
display error messages.
</p>

<p>
Due to the important nature of the Pubcookie login server, the only other
services that should be run on the same system are those which receive an
equally high level of scrutiny for security.  As deployed at the
University of Washington, the Pubcookie login server is powered by the
Apache web server software. Other web server software which supports CGI
and SSL should also work, but this supposition has not been tested.
</p>

<h4><a name="authsvcs">Authentication Services</a></h4>

<p>
Most sites will want to use the login cgi's "basic" login flavor, which 
supports username/password single-sign-on authentication and a simple 
pluggable interface for talking to backend authentication services. 
(Currently no other flavors exist!)
</p>

<p>
The basic login flavor supports many different verifiers.  Some of the
ones shipped with Pubcookie as of this writing are:
</p>

<ul>
<li> "kerberos_v5": check username/password against a Kerberos 5 KDC. </li>
<li> "ldap": check username/password against an LDAP server. </li>
<li> "shadow": check username/password against <tt>/etc/shadow</tt> </li>
<li> "alwaystrue": allow any username/password combination to
authenticate. </li>
</ul>

<p>
You can set which verifier to be used with the "basic_verifier"
configuration parameter (see <a href="#runtime">Run-time
configuration</a>).  Some verifiers will allow or require further
customization; see the section referring to that verifier.
</p>

<h4><a name="apacheconfig">Apache Configuration</a></h4>

<h5>Choosing the location of your login page</h5>

<p>
Depending on your installation environment you may choose to install the
login server in a number of configurations.  Two general models are
presented here with any necessary Apache configuration directives.
</p>

<h5>Specifying the login URL as a directory</h5>

<p>
For a clean looking login URL you can install the login server to be the
default file in a directory.  The default filename, index.cgi, is a common
name for a cgi file that would be executed when only directory URL is
specified.
</p>

<p>
The University of Washington uses <a
href="https://weblogin.washington.edu/">https://weblogin.washington.edu/</a>
as the login server URL; it's very simple for users to identify in the 
browser's URL field.  </p>

<p>
The Apache config directive 'DirectoryIndex' tells Apache it how to
handle requests for directories.  See <a
href="http://httpd.apache.org/docs/mod/mod_dir.html#directoryindex">the
mod_dir documentation</a> for more information.  When a request is
made for a directory Apache will choose the first file it finds in the
DirectoryIndex list.</p>

<p>
Our DirectoryIndex line looks something like:
</p>

<pre>
DirectoryIndex index.html index.cgi
</pre>

<p>If this is the configuration you choose, make sure there isn't an
index.html file in the same directory as the index.cgi binary.</p>

<h5>Explicit specification of login cgi</h5>

<p>
The login cgi is not name dependant and can be deployed as index.cgi,
login.cgi, or some other CGI file if you like.  In can also be put in any
subdirectory you wish.</p>

<p>
Your login server's URL could be something like
<tt>https://www.example.edu/cgi-bin/login.cgi</tt>.
Some sites may do this avoid the confusion with the default index page.</p>

<p>
Depending how you want to configure things with Apache or which ever Web
server you want to use for the login server, your login server URL could
be something like <tt>https://www.myuniversity.edu/login</tt>
where /login is mapped to the CGI program (index.cgi or whatever you
rename it to).</p>

<p>
Application deployers will need to know your login server's URL in order
to configure each application server.</p>

<h5>Apache configuration directive you might have to tweak</h5>

<p>
Apache needs to know how to identify and handle cgi scripts.  Some
distributions of Apache will have the cgi handler disabled, you will
want to make sure the following line is in your httpd.conf and not 
commented out.</p>

<pre>
AddHandler cgi-script .cgi
</pre>

<h4><a name="build">Build the Pubcookie login server</a></h4>

<p>
This has been made easier with autoconf. (Thanks Jon Miner, University 
of Wisconsin!) To build a barebones login server, run:</p>

<pre>
$ ./configure --enable-login --disable-apache
$ make
$ make install
</pre>

<p>
This sequence will build and install the <tt>index.cgi</tt>,
<tt>keyserver</tt>, and <tt>keyclient</tt> binaries, using the default
directory prefix (<tt>/usr/local/pubcookie</tt>, henceforth called
<tt>{PUBCOOKIE_DIR}</tt>), along with the "alwaystrue" verifier.</p>

<p>
To build other verifiers (e.g. "kerberos_v5", "ldap", or "shadow") 
along with the login cgi look at the configure options and adjust 
accordingly:
</p>

<pre>
$ ./configure --help
</pre>

<h4><a name="runtime">Run-time Configuration</a></h4>

<p>
Most configuration of the login server can be done at run-time via
Pubcookie's <tt>config</tt> file. It is located at
<tt>{PUBCOOKIE_DIR}/config</tt> and has "attr: value" lines
throughout.  A sample configuration file is included as <a
href="config.sample"><tt>config.sample</tt></a>. A complete
explanation of all available configuration variables is 
available <a href="config.html">in the config documentation</a>.
</p>

<p>
Some of the more notable variables are:
</p>

<dl compact="compact">
<dt> debug </dt> 
<dd> An integer. A non-zero value enables debug logging.  The higher
  the number, the more debugging output that is generated.</dd>

<dt> login_uri </dt>
<dd> The complete URI of the login cgi (e.g. https://weblogin.example.edu)</dd>

<dt> enterprise_domain </dt>
<dd> The domain under which all hosts will live.  Must be at least a
 second level domain (e.g. <tt>example.edu</tt>).</dd>

<dt> basic_verifier </dt>
<dd> The verifier to use for the "basic" login flavor.</dd>

<dt> keymgt_uri </dt>
<dd> The location of the "keyserver" CGI.  See the <a href="#keymgt">Key
Management</a> section.</dd>

</dl>

<p>
The following configuration variables should refer to the same files 
that your web server uses for SSL.</p>

<dl compact="compact">
<dt> ssl_key_file </dt>
<dd> The location of the SSL key.</dd>

<dt> ssl_cert_file </dt>
<dd> The location of the SSL certificate.</dd>
</dl>

<p>
If your institution uses a single CA without any intermediate
certificates, set <tt>ssl_ca_file</tt> to the path of the CA's
certificate. If your institution uses multiple CAs or intermediate
certificates, you'll need a directory (<tt>ssl_ca_path</tt>) contain
those certificates named via their OpenSSL hashes. At least one of
<tt>ssl_ca_file</tt> and <tt>ssl_ca_path</tt> should be specified.</p>

<dl compact="compact">
<dt> ssl_ca_file</dt>
<dd> The location of a single CA.</dd>

<dt> ssl_ca_path</dt>
<dd> A directory containing files named after their OpenSSL hash.</dd>
</dl>

<p>See <a href="config.html">config.html</a> for a full list of attributes.</p>

<h4><a name="localization">Localization: Login Page Templates</a></h4>

<p>
Localization is carried out via your config file variables (see above), 
a set of page templates, and an ok_browsers file (see below). This section
describes the login page templates.

<p>
The login cgi serves up pages based on a set of HTML templates.
By default, these templates reside in <tt>{PUBCOOKIE_DIR}/login_templates</tt>, 
but the location can be set by changing <tt>template_root</tt> in your config 
file. Generic templates are installed by default in
<tt>{PUBCOOKIE_DIR}/login_templates.default</tt>.  They should be
copied to <tt>{PUBCOOKIE_DIR}/login_templates</tt> and they will 
serve as a starting point for further localization.
</p>

<p>
Note: For reference and comparison purposes, copies of CMU and 
Washington's login templates (of some vintage) are provided in this
source distribution. See <tt>src/login_templates.cmu</tt> and 
<tt>src/login_templates.uw</tt>, respectively.
</p>

<p>
The name of each template file can be set via the
<tt>{PUBCOOKIE_DIR}/config</tt> file.  The name for each config
variable is tmpl_{default_file_name}, and they are located relative to the
<tt>template_root</tt>.  (For example, the attribute that controls the
name of the login page is <tt>tmpl_login</tt>.)

<h5>Template Files (incomplete)</h5>

<p> We are in the process of reworking the template files to make them 
more user-friendly.  The list below will be updated as work progresses.</p>

<dl compact="compact">
 <dt>login</dt>
 <dd>The Login HTML page.
  <ol>Paramters
   <li>Login Server URL</li>
   <li>The reason for the redirect (pulled from the <tt>login_*</tt>
    snippets)</li>
   <li>Hidden fields maintaining state</li>
   <li>GetCred Hidden fields</li>
  </ol>
 </dd>
 <dt>login_bad_auth</dt>
 <dd>The error displayed when the authentication failed.</dd>
 <dt>login_cache_creds_wrong</dt>
 <dd>The error displayed when the single-signon credential is not the type
  that the application is requesting.  (Rarely seen.)</dd>
 <dt>login_nolcookie</dt>
 <dd>The error displayed when the user doesn't have or has an invalid login
  cookie</dd>
 <dt>login_reauth</dt>
 <dd>The error displayed when the application has requested that the user
  reauthenticate.</dd>
 <dt>status</dt>
 <dd>The status page displaying the time remaining on the login.
  <ol>Parameters
   <li>Refresh header</li>
   <li>User name</li>
   <li>Time remaining.</li>
  </ol>
 </dd>
</dl>

<h4><a name="moreconfig">More Configuration: User agent blocking via
ok_browsers file</a></h4>

<p>
The <tt>{PUBCOOKIE_DIR}/ok_browsers</tt> file contains a list of acceptable
browsers.  The idea behind ok_browsers is to block browsers that
either have a known security flaw (i.e. don't forget cookies when they
should) or don't work with Pubcookie.
</p>

<p>
Note: At the University of Washington, we've so far been too chicken to 
really use the 'ok_browsers' functionality to block browsers that we know 
don't work.  Our ok_browsers file has a single line: "Mozilla". This 
pattern matches most of the browsers we support and/or encounter; mainly 
MS Internet Explorer, Netscape, and Mozilla. Proceed according to your own 
policy.
</p>

<h4><a name="keymgt">Key Management</a></h4>

<p>
<tt>{PUBCOOKIE_DIR}/keys</tt> is the location of the keystore that the login
cgi uses.  The login cgi makes use of several different keys.
</p>

<h5>Generate or reuse keypairs for the login server</h5>

<p>
The pubcookie_login key and certificate are used to secure the "login
cookie" that maintains the single sign-on session with the login server.  
These files are kept exclusively on the login server. We recommend
that you reuse your existing private key and SSL server certificate
rather than generating a new keypair. The login cgi will automatically
do so if you set <tt>ssl_cert_file</tt> and <tt>ssl_key_file</tt>
correctly.</p>

<h5>Generate granting keypair for authentication assertions</h5>

<p>
Next, the pubcookie_granting keypair is needed to secure authentication
assertions sent from login server to application servers, as represented
by the "granting cookie".  The key is kept exclusively on the login
server; the certificate must be distributed to every application server.
</p>

<pre>
$ openssl req -new -x509 -nodes \
    -out /usr/local/pubcookie/keys/pubcookie_granting.cert \
    -newkey rsa:1024 -keyout /usr/local/pubcookie/keys/pubcookie_granting.key
</pre>

<p>If you want to place these files in a different location (than
<tt>{PUBCOOKIE_DIR}/keys/pubcookie_granting.{key,cert}</tt>), you'll
need to set the <tt>granting_cert_file</tt> and
<tt>granting_key_file</tt> attributes.</p>

<h5>Configure keyserver on the login server</h5>

<p>
<tt>keyserver</tt> is a program that maintains DES keys.
Unfortunately, due to subtleties in the key usage constraints, it is
unable to run as a CGI underneath a login server.  Instead, we
recommend that it be run from inetd.
</p>

<p>
Add a line like the following to the login server's
<tt>/etc/inetd.conf</tt>:</p>

<pre>
2222    stream  tcp     nowait  root    /usr/local/pubcookie/keyserver keyserver
</pre>

<p>
where <tt>/usr/local/pubcookie/keyserver</tt> is where the keyserver binary
is installed.  Make sure that your <tt>pubcookie/config</tt> file is
correctly configured.</p>

<p>
If you are using xinetd, you should create a file named <tt>keyserver</tt> in
<tt>/etc/xinetd.d</tt> with the following contents:</p>

<pre>
# description: pubcookie keyserver
service keyserver
{
	type			= UNLISTED
	protocol		= tcp
	port			= 2222
	disable			= no
	socket_type		= stream
	wait			= no
	user			= root
	group			= tty
	server			= /usr/local/pubcookie/bin/keyserver
}
</pre>

<p>After adding this line (or file), restart <tt>inetd</tt>.</p>

<h5>Generate a DES key for the login server with keyclient</h5>

<p>
Now run keyclient to generate a DES key for the login server:</p>

<pre>
% /usr/local/pubcookie/bin/keyclient
</pre>

<p>This will cause the keyserver program to generate a new DES key for
the login server to use to provide confidentiality for the login
cookies.</p>

<h5>Generating DES keys for the application servers with keyclient</h5>

<p>
Generating DES keys for the application servers is just as easy as
above---in fact, the exact same command works.</p>

<p>
It is important that the application server's SSL certicate is signed
by the same certificate authority as is configured in the login
server's config file.</p>

<p>
Remember that the application server will also need a correct 'config'
file.</p>

<h4><a name="logout">Logout Configuration</a></h4>

<p>The login cgi automatically handles logout requests from applications.
This functionality is built in; no configuration is necessary on the login 
server. Through additional configuration you can create a separate logout
URL on your login server and also tailor some of the logout text for your
favoriate applications.</p>

<p>Note: Pubcookie 3.0 does not support "global" logout: logout of all
applications, all cookies, all at once. Rather, it supports per-application
logout, plus the ability to logout of the login server, all separately.
Therefore, users must still be educated and warned to exit their browser 
in order to get logged out of everything at once.</p>

<h5>Configuring a Logout URI</h5>

<p>If you want to provide a URL where users can go directly to clear their 
single sign-on session (pubcookie login cookie), it can be created with 
the logout_prog config variable and a Unix symbolic link. Here's an example.</p>

<p>Suppose the login cgi has been installed in the web server's root directory
(e.g. https://weblogin.example.edu) and you want to create a logout URI of "/logout/"
just below that (e.g. https://weblogin.example.edu/logout/). First, you would want
to create the subdirectory and symbolic link to your login cgi:

<pre>
$ cd /var/www/html
$ ls
index.cgi     images/
$ mkdir logout
$ cd logout
$ ln -s ../index.cgi index.cgi
</pre>

<p>Now any request to /logout/ on the server will map to your login cgi.
(editor: Is there a better way to do this in httpd.conf instead?) All that's left
is adding the appropriate <tt>logout_prog</tt> variable to your Pubcookie config file:</p>

<pre>
logout_prog: /logout/index.cgi
</pre>

<h5>Customizing Logout Responses For Special Apps </h5>

<p>The login cgi builds logout response pages from several templates. One template, 
<tt>logout_app</tt>, which is the most specific to each application, can be overridden 
on a per-application basis, as configured and identified by the originating server 
name and application id. It requires one <tt>app_logout_string</tt> config file variable
for each application, where the server name and id are tacked on using dashes. For example:

<pre>
# custom logout msgs
app_logout_string-appserver.example.edu-testapp: &lt;font size="+1"&gt;Testapp logout worked just fine.&lt;/font&gt;
app_logout_string-webmail.example.edu-webmail: &lt;font size="+1"&gt;Webmail Logout Successful!&lt;/font&gt;
</pre>

<p>Note: Since the login cgi reads the config file and its HTML templates on each request, 
there's no need to recompile the login cgi in order to modify response text.</p>

<h4><a name="upgrading">Upgrading</a></h4>

<h5>Upgrading from pre-3.0 pubcookie</h5>

<ul>
<li>Maintaining DES key compatibility from hashed IP addresses

<p>
If you have an exisiting pubcookie installation using a shared DES key
with hashed IP addresses, you can upgrade your login server without 
generating new keys on every application server.
</p>

<p>
On the login server, in the .../pubcookie/keys/ directory, make a copy of
the master DES key (before hashing it to any IP address) for each application
server, named with the full hostname of the server.</p>

<p>
For example, create <tt>.../pubcookie/keys/oldappserver.example.edu</tt>
containing the original DES keyfile.</p>

<p>
The login server will use this key to encrypt data going to that application
server, and the application server can continue to use it's key (XOR'd with
it's IP address) to decrypt the data.</p>

<p>
During the application server's next scheduled downtime, you can
create a new unique DES key for that application, as in the <a
href="#keymgt">Key management</a> section above.</p></li>

</ul>

<h4><a name="advconfig">Advanced Configuration</a></h4>

<h5>Redundant login servers</h5>

<h5>Redundant application hosts</h5>

<p>
Sites frequently want several hosts configured identically to provide
redundancy (either for performance or stability). In this section,
we're assuming that you have a set of machines with an identical SSL
certificate and key on them.</p>

<p>For instance, an institution might have 15 webmail servers named
<tt>webmail1.example.edu</tt> through <tt>webmail15.example.edu</tt>
with 15 unique IP addresses. All of them are equipped with a
<tt>webmail.example.edu</tt> certificate and are behind a Cisco Load
Director which controls the IP address for
<tt>webmail.example.edu</tt>.</p>

<p>Use <tt>keyclient</tt> on <tt>webmail1.example.edu</tt> to generate
a <tt>webmail.example.edu</tt> DES key. Use <tt>keyclient -d</tt> on
all other webmail machines (<tt>webmail2.example.edu</tt>, etc.) to
download an identical application key to the remaining servers.</p>

<h4><a name="security">Security Considerations</a></h4>

<h5>Login server security</h5>

don't run anything else on it: anyone who can add content
to the login server can steal all cookies

<h5>Application server security</h5>

<h5>Handling secrets</h5>

<h5>Other stuff</h5>

<h4><a name="oldtools">Old Tools That Might Be Handy for Debugging</a></h4>

<p>
<tt>pbc_create</tt> creates a pubcookie cookie, convenient for
creating cookies ad hoc.  Arguments come in via stdin and the cookie
is put out on stdout.  Args are space delimited, and in order: user
appsrvid appid type creds serial crypt_file cert_key_file.  Anything
too big is just truncated, no support for defaults or anything like
that.  See src for details.</p>

<p>
<tt>pbc_verify</tt> decrypts/verifies/displays pubcookie cookies,
convenient for 'unbundling' a cookie and seeing what's inside.  The
arguments come in on the command line, the cookie comes in on stdid,
and the contents are dumped to stdout.  The required argument is
cookie_type and the optional arguments are encryption_key and
cert_file.</p>

<p>
As an example you can use these two programs to do things like:</p>

<pre>
# echo "willey appsrvid appid 1 2 23 \
    /usr/local/pubcookie/c_key /usr/local/pubcookie/test.key" | \
    ./pbc_create | \
    ./pbc_verify 1 /usr/local/pubcookie/c_key /usr/local/pubcookie/test.cert
</pre>

<p>and get something like</p>

<pre>
user: willey
version: a5
type: 1
creds: 2
serial: 23
appsrvid: appsrvid
appid: appid
create_ts: 1006986719
last_ts: 1006986719
</pre>

<hr>
<p>
Copyright 1999-2003, University of Washington.  All rights reserved.<br>
See doc/LICENSE.txt for terms of use.
</p>
<pre>
$Id: install-login.html,v 1.8 2003-03-29 00:32:09 dors Exp $
</pre>
</body>

</html>



