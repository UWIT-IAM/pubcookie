<html>

<head>
<title>Pubcookie login cgi</title>
<link rel="stylesheet" href="pubcookie.css" type="text/css" title="pubcookie">
</head>

<body>

<h1>Pubcookie login cgi</h1>

<p>
Note: Documentation can contain bugs too. The  
<a href="http://www.pubcookie.org/docs/install-login.html">online            
version of this document</a> is always the most up-to-date version.
</p>


<p><i>Included on this page:</i></p>

<ul>
<li><a href="#intro">Introduction</a></li>
<li><a href="#implementation">Implementation</a></li>
<li><a href="#authsvcs">Authentication Services</a></li>
<li><a href="#apacheconfig">Apache Configuration</a></li>
<li><a href="#build">Build &amp; Install the Login Server Components</a></li>
<li><a href="#config">Setup Run-time Pubcookie Config File</a></li>
<li><a href="#keymgt">Key Management &amp; Setup</a></li>
<li><a href="#keyserver">Keyserver Setup</a></li>
<li><a href="#keyclient">Run Keyclient For Login Server</a></li>
<li><a href="#install">Install &amp; Test Login CGI (index.cgi)</a></li>
<li><a href="#templates">Login Page Templates</a></li>
<li><a href="#ok_browsers">The "ok_browsers" File</a></li>
<li><a href="#logout">Logout Configuration</a></li>
<li><a href="#upgrading">Upgrading</a></li>  
<li><a href="#advconfig">Advanced Configuration</a></li>
<li><a href="#security">Security Considerations</a></li>
<li><a href="#oldtools">Old Debugging Tools</a></li>
</ul>

<h4><a name="intro">Introduction</a></h2>

<p>
The Pubcookie login server has two primary functions: to authenticate
users and to issue authentication tokens (granting cookies) consumed by
Pubcookie-enabled target application servers.  Authentication occurs
either by verifying user-provided credentials via a backend authentication
service (Kerberos, LDAP, etc.) or by checking a token that was created
on a previous visit to the login server.  Example code to interface to an
authentication system is provided.
</p>

<h4><a name="implementation">Implementation</a></h4>

<p>
The Pubcookie login server consists of two primary components: a CGI 
program and a keyserver.
</p>

<p>
The Pubcookie login server uses the CGI program to handle all HTTP
requests.  This CGI program, hereafter referred to as "the login cgi"
or <tt>index.cgi</tt>, is compiled from C and is the central Pubcookie
component.  The login cgi displays the web page where users are asked
to enter authentication credentials as well as other web pages that
display error messages.
</p>

<p>
The Pubcookie login server uses the keyserver to generate, distribute,
and manage DES keys for application servers.
</p>

<p>
Due to the important nature of the Pubcookie login server, the only other
services that should be run on the same system are those which receive an
equally high level of scrutiny for security.  As deployed at the
University of Washington, the Pubcookie login server is powered by the
Apache web server software. Other web server software which supports CGI
and SSL should also work, but this supposition has not been tested.
</p>

<h4><a name="authsvcs">Authentication Services</a></h4>

<p>
The login cgi is designed to support different authentication feature
sets by abstracting them into login "flavors". However, only one login 
flavor is currently provided: the "basic" login flavor. The basic login 
flavor supports username/password single-sign-on authentication and a 
simple pluggable interface to backend authentication services called 
"verifiers." Pubcookie currently ships with several verifiers for the 
basic login flavor:
</p>

<ul>
<li> "kerberos_v5": check username/password against a Kerberos 5 KDC. </li>
<li> "ldap": check username/password against an LDAP server. </li>
<li> "shadow": check username/password against <tt>/etc/shadow</tt>. </li>
<li> "alwaystrue": allow any username/password combination to authenticate. </li>
</ul>

<p>
You can choose which verifiers to build at compile time and then decide at run-time 
which verifier is used by the basic login flavor by setting the "basic_verifier" 
configuration variable (see <a href="#config">run-time configuration</a>).  Some 
verifiers allow or require further configuration; see the section referring to each 
verifier for details.
</p>

<h4><a name="apacheconfig">Apache Configuration</a></h4>

<h5>Choosing the location of your login page</h5>

<p>
Depending on your deployment environment, you may choose to install the
login server in a number of configurations.  Two general models are
presented here, along with the necessary Apache configuration directives
for each.
</p>

<h5>Specifying the login server URL as a directory</h5>

<p>
For a clean looking URL for your login server, you can install the login cgi
as the default file in a directory. For example, the University of Washington 
uses the server's root directory, resulting in <i>https://weblogin.washington.edu/</i> 
as the login server URL. This address is easy for users to identify in a browser's 
address field.
</p>

<p>
The default binary filename for the login cgi, <tt>index.cgi</tt>, is a common 
name for a cgi program that will be executed when a directory's URL is requested.
The <a href="http://httpd.apache.org/docs/mod/mod_dir.html#directoryindex"><tt>DirectoryIndex</tt></a> 
directive tells Apache how to handle requests to directories.  See the <a
href="http://httpd.apache.org/docs/mod/mod_dir.html">mod_dir documentation</a> 
for more information on its use.  When a request is
made for a directory, Apache will choose the first file it finds in the
DirectoryIndex list. This can be your login cgi.</p>

<p>
For example, you might use the follow <tt>DirectoryIndex</tt> directive:
</p>

<pre>
DirectoryIndex index.html index.cgi
</pre>

<p>
If this is the configuration you choose, make sure there isn't an
index.html file in the same directory as the index.cgi binary.
</p>

<h5>Explicit specification of login cgi</h5>

<p>
The login cgi does not depend on its own filename. Therefore, it can be 
deployed as index.cgi, login.cgi, or any other filename handled as a
cgi script. It can also be put in any subdirectory you wish. Thus,
it really depends on what you want users to see and how you want to
configure things in Apache.
</p>

<p>
To avoid conflict or confusion with the server's main page, you might
deploy a login server at <i>https://www.example.edu/cgi-bin/login.cgi</i>
or maybe <i>https://www.example.edu/login</i> where <i>/login</i> is 
mapped to the login cgi (index.cgi or whatever you rename it to).
</p>

<p>
Note: in order to configure applications servers, other system administrators 
will need to know the URL of your login server.
</p>

<h5>Apache configuration directive you might have to tweak</h5>

<p>
Apache needs to know how to identify and handle cgi scripts.  Some
distributions of Apache will have the cgi handler disabled, you will
want to make sure the following line is in your httpd.conf and not 
commented out.
</p>

<pre>
AddHandler cgi-script .cgi
</pre>

<h4><a name="build">Build &amp; Install the Login Server Components</a></h4>

<p>
Compiling the source code has been made easier with autoconf. (Thanks Jon Miner, 
University of Wisconsin!)
</p>

<p>To build a barebones login server, run:</p>

<pre>
$ ./configure --enable-login --disable-apache
$ make
</pre>

<p>
This will build the login cgi and its "alwaystrue" verifier, as well
as the keyserver and keyclient binaries. It also prepares for
installation using the default installation directory prefix, henceforth 
called <tt>{PUBCOOKIE_DIR}</tt>, of <tt>/usr/local/pubcookie</tt>.
</p>

<p>
To build other verifiers (e.g. "kerberos_v5", "ldap", or "shadow")
along with the other base components, look at the configure options and 
re-run the configure script accordingly:
</p>

<pre>
$ ./configure --help
</pre>

<p>To install the login server components into the installation directory, 
run:</p>

<pre>
$ make install
</pre>

<p>Now you can view the results by listing the contents of
<tt>{PUBCOOKIE_DIR}</tt>.</p>

<pre>
$ ls /usr/local/pubcookie
keyclient  keys  keyserver  login  login_templates  login_templates.default
</pre>

<h4><a name="config">Setup Run-time Pubcookie Config File</a></h4>

<p>
The login cgi and keyserver share a simple configuration file:
the Pubcookie <tt>config</tt> file. Most run-time configuration 
can be set up via this file, which is located at
<tt>{PUBCOOKIE_DIR}/config</tt>. The format is one attribute-value
pair per line.
</p>

<p>
A <a href="config.login.sample">sample config file</a> appropriate for
a login server is provided as a starting point. You might consider 
copying it to <tt>{PUBCOOKIE_DIR}/config</tt> and edit it there, e.g.:
</p>

<pre>
$ cp doc/config.login.sample /usr/local/pubcookie/config
</pre>

<p>
Refer to the <a href="config.html">config 
documentation</a> to setup your configuration file. Some of the more notable 
variables are:
</p>

<dl compact="compact">
<dt> debug </dt> 
<dd> An integer. A non-zero value enables debug logging.  The higher
  the number, the more debugging output that is generated.</dd>

<dt> login_host </dt>
<dd> The hostname of login server (e.g. weblogin.example.edu)</dd>

<dt> login_uri </dt>
<dd> The complete URI of the login cgi (e.g. https://weblogin.example.edu)</dd>

<dt> enterprise_domain </dt>
<dd> The domain under which all hosts will live.  Must be at least a
 second level domain (e.g. <tt>example.edu</tt>).</dd>

<dt> basic_verifier </dt>
<dd> The verifier to use for the "basic" login flavor.</dd>

<dt> keymgt_uri </dt>
<dd> The location of the "keyserver" CGI.  See the <a href="#keymgt">Key
Management</a> section.</dd>

</dl>

<p>
The following configuration variables are crucial, as they determine
the keypair used to sign and verify "login" cookies and more importantly
to authenticate your keyserver's identity. In most cases, they should 
refer to the same files that your web server uses for SSL.</p>

<dl compact="compact">
<dt> ssl_key_file </dt>
<dd> The location of the SSL key.</dd>

<dt> ssl_cert_file </dt>
<dd> The location of the SSL certificate.</dd>
</dl>

<p>
The following configuration variables define which Certificate
Authority (CA) is trusted by your keyserver.
If your institution uses a single CA without any intermediate
certificates, set <tt>ssl_ca_file</tt> to the full path to the CA's
root certificate. If your institution uses multiple CAs or intermediate
certificates, you'll need a directory (<tt>ssl_ca_path</tt>) containing
those certificates named via their OpenSSL hashes. At least one of
<tt>ssl_ca_file</tt> and <tt>ssl_ca_path</tt> must be specified.</p>

<dl compact="compact">
<dt> ssl_ca_file</dt>
<dd> The location of a single CA.</dd>

<dt> ssl_ca_path</dt>
<dd> A directory containing files named after their OpenSSL hash.</dd>
</dl>

<p>Again, see <a href="config.html">config.html</a> for a full list of 
configuration variables and their descriptions.</p>

<h4><a name="keymgt">Key Management &amp; Setup</a></h4>

<p>
<tt>{PUBCOOKIE_DIR}/keys</tt> is the location of the keystore used by
the login cgi.  The login cgi makes use of several different keys.
</p>

<h5>Reuse SSL keypairs for the "login" cookie and keyserver</h5>

<p>
The login cgi uses a keypair to sign and verify the "login" cookie
that maintains a user's single sign-on session with the login server.  
These files are kept exclusively on the login server and are also
used by the keyserver. We recommend that you reuse your existing private 
key and SSL server certificate, rather than generating a new keypair. 
The login cgi will automatically do so if you set <tt>ssl_cert_file</tt> 
and <tt>ssl_key_file</tt> correctly. If this works for your keyserver, it 
is probably the optimal solution.
</p>

<h5>Generate granting keypair for authentication assertions</h5>

<p>
Next, a "granting" keypair is needed to secure authentication
assertions sent from login server to application servers, as represented
by a "granting" cookie.  The key is kept exclusively on the login
server; the certificate must be distributed to every application server.
We've historically recommend that you generate a new keypair for this 
purpose, although you could reuse you SSL keypair here too. 
</p>

<pre>
$ openssl req -new -x509 -nodes \
    -out /usr/local/pubcookie/keys/pubcookie_granting.cert \
    -newkey rsa:1024 -keyout /usr/local/pubcookie/keys/pubcookie_granting.key
</pre>

<p>If you want to place these files in a different location (than
<tt>{PUBCOOKIE_DIR}/keys/pubcookie_granting.{key,cert}</tt>), you'll
need to set the <tt>granting_cert_file</tt> and
<tt>granting_key_file</tt> variables in your config file.</p>

<h4><a name="keyserver">Keyserver Setup</a></h4>

<p>
The <tt>keyserver</tt> binary you build earlier is a program that generates 
and maintains DES keys for participating servers to use to encrypt cookie
contents. Unfortunately, due to subtleties in the key usage constraints, 
keyserver is unable to run as a cgi script underneath a login server. Instead, 
we recommend that keyserver be run from inetd.
</p>

<p>
Add a line like the following to the login server's
<tt>/etc/inetd.conf</tt>:
</p>

<pre>
2222    stream  tcp     nowait  root    /usr/local/pubcookie/keyserver keyserver
</pre>

<p>
where <tt>/usr/local/pubcookie/keyserver</tt> is where the keyserver binary
is installed.  Make sure that your <tt>pubcookie/config</tt> file is
correctly configured.</p>

<p>
If you are using xinetd, you should create a file named <tt>keyserver</tt> in
<tt>/etc/xinetd.d</tt> with the following contents:</p>

<pre>
# description: pubcookie keyserver
service keyserver
{
	type			= UNLISTED
	protocol		= tcp
	port			= 2222
	disable			= no
	socket_type		= stream
	wait			= no
	user			= root
	group			= tty
	server			= /usr/local/pubcookie/bin/keyserver
}
</pre>

<p>After adding this line to inetd.conf (or file to xinetd), restart <tt>inetd</tt>
(or xinetd).</p>

<h4><a name="keyclient">Run Keyclient for the Login Server</a></h4>

<h5>Generate a DES key for the login server with keyclient</h5>

<p>
Now run keyclient to generate a DES key for the login server:</p>

<pre>
% /usr/local/pubcookie/bin/keyclient
</pre>

<p>This will cause the keyserver program to generate a new DES key for
the login server to use to provide confidentiality for the login
cookies.</p>

<h5>Generating DES keys for the application servers with keyclient</h5>

<p>
When the time comes, generating DES keys for application servers is 
very similar. You configure the keyclient on the application server
ahead of time, making sure the keyclient's certicate (probably the
server's SSL certificate) is signed by the same CA trusted by your 
keyserer's CA configuration. Refer to the application server documentation
for specifics.</p>

<h4><a name="install">Install &amp; Test Login CGI (index.cgi)</a></h4>

<p>Once your run-time config file is set up and you've succeeded in using
keyclient to generate a DES key for your login server, you can deploy the
login cgi by copying it into your production directory from which Apache
will serve requests. (See <a href="#apacheconfig">Apache Configuration</a> 
above for some discussion of this topic.) For example:</p>

<pre>
% cp index.cgi /var/www/html
</pre>

<p>You don't need to set up an application server to test the login cgi; 
simply open your login URL in a browser and it should ask you to log in
using whichever verifier you've configured. This direct approach to
your login cgi is known as a "pinit" or "Pubcookie init" since it 
establishes a single sign-on session without authenticating you to 
any applications.</p>

<h4><a name="templates">Login Page Templates</a></h4>

<p>
The login cgi serves up pages based on a set of HTML templates.
By default, these templates reside in <tt>{PUBCOOKIE_DIR}/login_templates</tt>, 
but the location can be set by changing <tt>template_root</tt> in your config 
file. Generic templates are installed by default in
<tt>{PUBCOOKIE_DIR}/login_templates.default</tt>.  They should be
copied to <tt>{PUBCOOKIE_DIR}/login_templates</tt> and they will 
serve as a starting point for further localization.
</p>

<p>
Note: For reference and comparison purposes, copies of CMU and 
Washington's login templates (of some vintage) are provided in this
source distribution. See <tt>src/login_templates.cmu</tt> and 
<tt>src/login_templates.uw</tt>, respectively. Note: the syntax
for variable substitution within the templates changed during the
development of version 3.0.0. The UWash and CMU templates may be in 
the older format.
</p>

<p>
The name of each template file can be set via the
<tt>{PUBCOOKIE_DIR}/config</tt> file.  The name for each config
variable is tmpl_{default_file_name}, and they are located relative to the
<tt>template_root</tt>.  (For example, the attribute that controls the
name of the login page is <tt>tmpl_login</tt>.)

<h5>Template Files (incomplete)</h5>

<p> We are in the process of reworking the template files to make them 
more user-friendly.  The list below will be updated as work progresses.</p>

<dl compact="compact">
 <dt>login</dt>
 <dd>The Login HTML page.
  <ol>Paramters
   <li>Login Server URL</li>
   <li>The reason for the redirect (pulled from the <tt>login_*</tt>
    snippets)</li>
   <li>Hidden fields maintaining state</li>
   <li>GetCred Hidden fields</li>
  </ol>
 </dd>
 <dt>login_bad_auth</dt>
 <dd>The error displayed when the authentication failed.</dd>
 <dt>login_cache_creds_wrong</dt>
 <dd>The error displayed when the single-signon credential is not the type
  that the application is requesting.  (Rarely seen.)</dd>
 <dt>login_nolcookie</dt>
 <dd>The error displayed when the user doesn't have or has an invalid login
  cookie</dd>
 <dt>login_reauth</dt>
 <dd>The error displayed when the application has requested that the user
  reauthenticate.</dd>
 <dt>status</dt>
 <dd>The status page displaying the time remaining on the login.
  <ol>Parameters
   <li>Refresh header</li>
   <li>User name</li>
   <li>Time remaining.</li>
  </ol>
 </dd>
</dl>

<h4><a name="ok_browsers">The "ok_browsers" File</a></h4>

<p>
The <tt>{PUBCOOKIE_DIR}/ok_browsers</tt> file contains a list of acceptable
browsers.  The idea behind ok_browsers is to block browsers that
either have a known security flaw (i.e. don't forget cookies when they
should) or don't work with Pubcookie. The ok_browsers file is optional.
</p>

<p>
Note: At the University of Washington, we've so far been too chicken to 
really use the 'ok_browsers' functionality to block browsers that we know 
don't work.  Our ok_browsers file has a single line: "Mozilla". This 
pattern matches most of the browsers we support and/or encounter; mainly 
MS Internet Explorer, Netscape, and Mozilla. Proceed according to your own 
policy.
</p>

<h4><a name="logout">Logout Configuration</a></h4>

<p>The login cgi automatically handles logout requests from applications.
This functionality is built in; no configuration is necessary on the login 
server. Through additional configuration you can create a separate logout
URL on your login server and also tailor some of the logout text for your
favoriate applications.</p>

<p>Note: Pubcookie 3.0 does not support "global" logout: logout of all
applications, all cookies, all at once. Rather, it supports per-application
logout, plus the ability to logout of the login server, all separately.
Therefore, users must still be educated and warned to exit their browser 
in order to get logged out of everything at once.</p>

<h5>Configuring a Logout URI</h5>

<p>If you want to provide a URL where users can go directly to clear their 
single sign-on session (pubcookie login cookie), it can be created with 
the logout_prog config variable and a Unix symbolic link. Here's an example.</p>

<p>Suppose the login cgi has been installed in the web server's root directory
(e.g. https://weblogin.example.edu) and you want to create a logout URI of "/logout/"
just below that (e.g. https://weblogin.example.edu/logout/). First, you would want
to create the subdirectory and symbolic link to your login cgi:

<pre>
$ cd /var/www/html
$ ls
index.cgi     images/
$ mkdir logout
$ cd logout
$ ln -s ../index.cgi index.cgi
</pre>

<p>Now any request to /logout/ on the server will map to your login cgi.
(editor: Is there a better way to do this in httpd.conf instead?) All that's left
is adding the appropriate <tt>logout_prog</tt> variable to your Pubcookie config file:</p>

<pre>
logout_prog: /logout/index.cgi
</pre>

<h5>Customizing Logout Responses For Special Apps </h5>

<p>The login cgi builds logout response pages from several templates. One template, 
<tt>logout_app</tt>, which is the most specific to each application, can be overridden 
on a per-application basis, as configured and identified by the originating server 
name and application id. It requires one <tt>app_logout_string</tt> config file variable
for each application, where the server name and id are tacked on using dashes. For example:

<pre>
# custom logout msgs
app_logout_string-appserver.example.edu-testapp: &lt;font size="+1"&gt;Testapp logout worked just fine.&lt;/font&gt;
app_logout_string-webmail.example.edu-webmail: &lt;font size="+1"&gt;Webmail Logout Successful!&lt;/font&gt;
</pre>

<p>Note: Since the login cgi reads the config file and its HTML templates on each request, 
there's no need to recompile the login cgi in order to modify response text.</p>

<h4><a name="upgrading">Upgrading</a></h4>

<h5>Upgrading from pre-3.0 pubcookie</h5>

<ul>
<li>Maintaining DES key compatibility from hashed IP addresses

<p>
If you have an exisiting pubcookie installation using a shared DES key
with hashed IP addresses, you can upgrade your login server without 
generating new keys on every application server.
</p>

<p>
On the login server, in the .../pubcookie/keys/ directory, make a copy of
the master DES key (before hashing it to any IP address) for each application
server, named with the full hostname of the server.</p>

<p>
For example, create <tt>.../pubcookie/keys/oldappserver.example.edu</tt>
containing the original DES keyfile.</p>

<p>
The login server will use this key to encrypt data going to that application
server, and the application server can continue to use it's key (XOR'd with
it's IP address) to decrypt the data.</p>

<p>
During the application server's next scheduled downtime, you can
create a new unique DES key for that application, as in the <a
href="#keymgt">Key Management &amp; Setup</a> section above.</p></li>

</ul>

<h4><a name="advconfig">Advanced Configuration</a></h4>

<h5>Redundant login servers</h5>

<h5>Redundant application hosts</h5>

<p>
Sites frequently want several hosts configured identically to provide
redundancy (either for performance or stability). In this section,
we're assuming that you have a set of machines with an identical SSL
certificate and key on them.</p>

<p>For instance, an institution might have 15 webmail servers named
<tt>webmail1.example.edu</tt> through <tt>webmail15.example.edu</tt>
with 15 unique IP addresses. All of them are equipped with a
<tt>webmail.example.edu</tt> certificate and are behind a Cisco Load
Director which controls the IP address for
<tt>webmail.example.edu</tt>.</p>

<p>Use <tt>keyclient</tt> on <tt>webmail1.example.edu</tt> to generate
a <tt>webmail.example.edu</tt> DES key. Use <tt>keyclient -d</tt> on
all other webmail machines (<tt>webmail2.example.edu</tt>, etc.) to
download an identical application key to the remaining servers.</p>

<h4><a name="security">Security Considerations</a></h4>

<h5>Login server security</h5>

<p>Don't run anything else on it: anyone who can add content
to the login server can steal all cookies.</p>

<h5>Application server security</h5>

<h5>Handling secrets</h5>

<h5>Other stuff</h5>

<h4><a name="oldtools">Old Tools That Might Be Handy for Debugging</a></h4>

<p>
<tt>pbc_create</tt> creates a pubcookie cookie, convenient for
creating cookies ad hoc.  Arguments come in via stdin and the cookie
is put out on stdout.  Args are space delimited, and in order: user
appsrvid appid type creds serial crypt_file cert_key_file.  Anything
too big is just truncated, no support for defaults or anything like
that.  See src for details.</p>

<p>
<tt>pbc_verify</tt> decrypts/verifies/displays pubcookie cookies,
convenient for 'unbundling' a cookie and seeing what's inside.  The
arguments come in on the command line, the cookie comes in on stdid,
and the contents are dumped to stdout.  The required argument is
cookie_type and the optional arguments are encryption_key and
cert_file.</p>

<p>
As an example you can use these two programs to do things like:</p>

<pre>
# echo "willey appsrvid appid 1 2 23 \
    /usr/local/pubcookie/c_key /usr/local/pubcookie/test.key" | \
    ./pbc_create | \
    ./pbc_verify 1 /usr/local/pubcookie/c_key /usr/local/pubcookie/test.cert
</pre>

<p>and get something like</p>

<pre>
user: willey
version: a5
type: 1
creds: 2
serial: 23
appsrvid: appsrvid
appid: appid
create_ts: 1006986719
last_ts: 1006986719
</pre>

<hr>
<p>
Copyright 1999-2003, University of Washington.  All rights reserved.<br>
See doc/LICENSE.txt for terms of use.
</p>
<pre>
$Id: install-login.html,v 1.12 2003-05-27 18:00:16 dors Exp $
</pre>
</body>

</html>
