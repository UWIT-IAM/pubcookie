<html>

<head>
<title>Pubcookie login cgi</title>
<link rel="stylesheet" href="pubcookie.css" type="text/css" title="pubcookie">
</head>

<body>

<h1>Pubcookie login cgi</h1>

<p>
Note: Documentation can contain bugs too. The  
<a href="http://www.pubcookie.org/docs/install-login.html">online            
version of this document</a> is always the most up-to-date version.
</p>


<p><i>Included on this page:</i></p>

<ul>
<li><a href="#intro">Introduction</a></li>
<li><a href="#implementation">Implementation</a></li>
<li><a href="#authsvcs">Authentication Services</a></li>
<li><a href="#apacheconfig">Apache Configuration</a></li>
<li><a href="#build">Build &amp; Install the Login Server Components</a></li>
<li><a href="#config">Setup Run-time Pubcookie Config File</a></li>
<li><a href="#keypairs">Setup Login Server Key Pairs</a></li>
<li><a href="#keymgmt">Shared DES Key Management</a></li>
<li><a href="#keyserver">Keyserver Setup</a></li>
<li><a href="#keyclient">Run Keyclient For Login Server</a></li>
<li><a href="#install">Install &amp; Test Login CGI (index.cgi)</a></li>
<li><a href="#debug">Logging &amp; Debugging</a></li>
<li><a href="#templates">Login Page Templates</a></li>
<li><a href="#ok_browsers">Browser Acceptance Configuration</a></li>
<li><a href="#logout">Logout Configuration</a></li>
<li><a href="#kiosk">Kiosk Configuration</a></li>
<li><a href="#krb5">Kerberos 5 Verifier Configuration</a></li>
<li><a href="#upgrading">Upgrading</a></li>  
<li><a href="#advconfig">Advanced Configuration</a></li>
<li><a href="#security">Security Considerations</a></li>
<li><a href="#oldtools">Old Debugging Tools</a></li>
</ul>

<h4><a name="intro">Introduction</a></h4>

<p>
The Pubcookie login server has two primary functions: to authenticate
users and to issue authentication tokens (granting cookies) consumed by
Pubcookie-enabled target application servers.  Authentication occurs
either by verifying user-provided credentials via a backend authentication
service (Kerberos, LDAP, etc.) or by checking a token that was created
on a previous visit to the login server.  Example code to interface to an
authentication system is provided.
</p>

<h4><a name="implementation">Implementation</a></h4>

<p>
The Pubcookie login server consists of two primary components: a CGI 
program and a keyserver.
</p>

<p>
The Pubcookie login server uses the CGI program to handle all HTTP
requests.  This CGI program, hereafter referred to as "the login cgi"
or <tt>index.cgi</tt>, is compiled from C and is the central Pubcookie
component.  The login cgi displays the web page where users are asked
to enter authentication credentials as well as other web pages that
display error messages.
</p>

<p>
The Pubcookie login server uses the keyserver to generate, distribute,
and manage DES keys for application servers.
</p>

<p>
Due to the important nature of the Pubcookie login server, the only other
services that should be run on the same system are those which receive an
equally high level of scrutiny for security.  As deployed at the
University of Washington, the Pubcookie login server is powered by the
Apache web server software. Other web server software which supports CGI
and SSL should also work, but this supposition has not been tested.
</p>

<h4><a name="authsvcs">Authentication Services</a></h4>

<p>
The login cgi is designed to support different authentication feature
sets by abstracting them into login "flavors". However, only one login 
flavor is currently provided: the "basic" login flavor. The basic login 
flavor supports username/password single-sign-on authentication and a 
simple pluggable interface to backend authentication services called 
"verifiers." Pubcookie currently ships with several verifiers for the 
basic login flavor:
</p>

<ul>
<li> "kerberos_v5": check username/password against a Kerberos 5 KDC. </li>
<li> "ldap": check username/password against an LDAP server. </li>
<li> "shadow": check username/password against <tt>/etc/shadow</tt>. </li>
<li> "alwaystrue": allow any username/password combination to authenticate. </li>
</ul>

<p>
You can choose which verifiers to build at compile time and then decide at run-time 
which verifier is used by the basic login flavor by setting the "basic_verifier" 
configuration variable (see <a href="#config">run-time configuration</a>).  Some 
verifiers allow or require further configuration; see the section referring to each 
verifier for details.
</p>

<h4><a name="apacheconfig">Apache Configuration</a></h4>

<h5>Choosing the location of your login page</h5>

<p>
Depending on your deployment environment, you may choose to install the
login server in a number of configurations.  Two general models are
presented here, along with the necessary Apache configuration directives
for each.
</p>

<h5>Specifying the login server URL as a directory</h5>

<p>
For a clean looking URL for your login server, you can install the login cgi
as the default file in a directory. For example, the University of Washington 
uses the server's root directory, resulting in <i>https://weblogin.washington.edu/</i> 
as the login server URL. This address is easy for users to identify in a browser's 
address field.
</p>

<p>
The default binary filename for the login cgi, <tt>index.cgi</tt>, is a common 
name for a cgi program that will be executed when a directory's URL is requested.
The <a href="http://httpd.apache.org/docs/mod/mod_dir.html#directoryindex"><tt>DirectoryIndex</tt></a> 
directive tells Apache how to handle requests to directories.  See the <a
href="http://httpd.apache.org/docs/mod/mod_dir.html">mod_dir documentation</a> 
for more information on its use.  When a request is
made for a directory, Apache will choose the first file it finds in the
DirectoryIndex list. This can be your login cgi.</p>

<p>
For example, you might use the follow <tt>DirectoryIndex</tt> directive:
</p>

<pre>
DirectoryIndex index.html index.cgi
</pre>

<p>
If this is the configuration you choose, make sure there isn't an
index.html file in the same directory as the index.cgi binary.
</p>

<h5>Explicit specification of login cgi</h5>

<p>
The login cgi does not depend on its own filename. Therefore, it can be 
deployed as index.cgi, login.cgi, or any other filename handled as a
cgi script. It can also be put in any subdirectory you wish. Thus,
it really depends on what you want users to see and how you want to
configure things in Apache.
</p>

<p>
To avoid conflict or confusion with the server's main page, you might
deploy a login server at <i>https://www.example.edu/cgi-bin/login.cgi</i>
or maybe <i>https://www.example.edu/login</i> where <i>/login</i> is 
mapped to the login cgi (index.cgi or whatever you rename it to).
</p>

<p>
Note: in order to configure applications servers, other system administrators 
will need to know the URL of your login server.
</p>

<h5>Apache configuration directive you might have to tweak</h5>

<p>
Apache needs to know how to identify and handle cgi scripts.  Some
distributions of Apache will have the cgi handler disabled, you will
want to make sure the following line is in your httpd.conf and not 
commented out.
</p>

<pre>
AddHandler cgi-script .cgi
</pre>

<h4><a name="build">Build &amp; Install the Login Server Components</a></h4>

<p>
Compiling the source code has been made easier with autoconf. (Thanks Jon Miner, 
University of Wisconsin!)
</p>

<p>To build a barebones login server, run:</p>

<pre>
$ ./configure --enable-login --disable-apache
$ make
</pre>

<p>
This will build the login cgi and its "alwaystrue" verifier, as well
as the keyserver and keyclient binaries. It also prepares for
installation using the default installation directory prefix, henceforth 
called <tt>{PUBCOOKIE_DIR}</tt>, of <tt>/usr/local/pubcookie</tt>.
</p>

<p>
To build other verifiers (e.g. "kerberos_v5", "ldap", or "shadow")
along with the other base components, look at the configure options and 
re-run the configure script accordingly:
</p>

<pre>
$ ./configure --help
</pre>

<p>To install the login server components into the installation directory, 
run:</p>

<pre>
$ make install
</pre>

<p>Now you can view the results by listing the contents of
<tt>{PUBCOOKIE_DIR}</tt>.</p>

<pre>
$ ls /usr/local/pubcookie
keyclient  keys  keyserver  login  login_templates  login_templates.default
</pre>

<h4><a name="config">Setup Run-time Pubcookie Config File</a></h4>

<p>
The login cgi and keyserver share a simple configuration file:
the Pubcookie <tt>config</tt> file. Most run-time configuration 
can be set up via this file, which is located at
<tt>{PUBCOOKIE_DIR}/config</tt>. The format is one attribute-value
pair per line, except where a trailing backslash "\" is used to continue
a value to the next line.
</p>

<p>
A <a href="config.login.sample">sample config file</a> appropriate for
a login server is provided as a starting point. You might consider 
copying it to <tt>{PUBCOOKIE_DIR}/config</tt> and edit it there, e.g.:
</p>

<pre>
$ cp doc/config.login.sample /usr/local/pubcookie/config
</pre>

<p>
Refer to the <a href="config.html">config 
documentation</a> to setup your configuration file. Some of the more notable 
variables are:
</p>

<dl compact="compact">
<dt> logging_level </dt> 
<dd> Defines the amount of logging.</dd>

<dt> login_host </dt>
<dd> The hostname of login server (e.g. weblogin.example.edu)</dd>

<dt> login_uri </dt>
<dd> The complete URI of the login cgi (e.g. https://weblogin.example.edu)</dd>

<dt> enterprise_domain </dt>
<dd> The domain under which all hosts will live.  Must be at least a
 second level domain (e.g. <tt>example.edu</tt>).</dd>

<dt> basic_verifier </dt>
<dd> The verifier to use for the "basic" login flavor.</dd>

<dt> keymgt_uri </dt>
<dd> The location of the keyserver.  See the <a href="#keymgt">Key
Management</a> section.</dd>

<dt> keyserver_client_list </dt>
<dd> The hosts that are authorized to "permit" new servers.</dd>

</dl>

<p>
The following configuration variables are crucial, as they determine
the key pair used to sign and verify "login" cookies and more importantly
to authenticate your keyserver's identity. In most cases, they should 
refer to the same files that your web server uses for SSL.</p>

<dl compact="compact">
<dt> ssl_key_file </dt>
<dd> The location of the SSL key.</dd>

<dt> ssl_cert_file </dt>
<dd> The location of the SSL certificate.</dd>
</dl>

<p>
The following configuration variables define which Certificate
Authority (CA) is trusted by your keyserver.
If your institution uses a single CA without any intermediate
certificates, set <tt>ssl_ca_file</tt> to the full path to the CA's
root certificate. If your institution uses multiple CAs or intermediate
certificates, you'll need a directory (<tt>ssl_ca_path</tt>) containing
those certificates named via their OpenSSL hashes. At least one of
<tt>ssl_ca_file</tt> and <tt>ssl_ca_path</tt> must be specified.</p>

<dl compact="compact">
<dt> ssl_ca_file</dt>
<dd> The location of a file of root CA info.</dd>

<dt> ssl_ca_path</dt>
<dd> A directory containing CA files named after their OpenSSL hash.</dd>
</dl>

<p>Again, see <a href="config.html">config.html</a> for a full list of 
configuration variables and their descriptions.</p>

<h4><a name="keypairs">Setup Login Server Key Pairs</a></h4>

<p>The login cgi uses a couple of special key pairs to sign and verify
cookie contents.  These key pairs are in addition to the DES encryption
keys it shares with application servers. <tt>{PUBCOOKIE_DIR}/keys</tt> is
the default location for all these keys.</p>

<h5>Reuse SSL key pairs for the "login" cookie and keyserver</h5>

<p>The login cgi uses a key pair to sign and verify the "login" cookie
that maintains a user's single sign-on session with the login server.  
These files are kept exclusively on the login server and are also used by
the keyserver. You can reuse your web server's existing SSL private key
and certificate, rather than generating a new key pair. As long as this
works for your keyserver, it is probably the optimal solution.  
Configuration is via the <tt>ssl_cert_file</tt> and <tt>ssl_key_file</tt>
config file variables.</p>

<h5>Generate granting key pair for authentication assertions</h5>

<p>Next, a "granting" key pair is needed to sign and verify the "granting"
cookies sent by the login server to application servers as authentication
assertions. Here the private key is kept exclusively on the login server,
and the public key certificate is distributed to each application server.
You can generate a new key pair for this purpose, although you can reuse
your SSL key pair too. The certificate issuer doesn't matter.</p>

<pre>
$ openssl req -new -x509 -nodes \
    -out /usr/local/pubcookie/keys/pubcookie_granting.crt \
    -newkey rsa:1024 -keyout /usr/local/pubcookie/keys/pubcookie_granting.key
</pre>

<p>If you want to name these files differently or place them in another
location, use the <tt>granting_cert_file</tt> and
<tt>granting_key_file</tt> config file variables.</p>

<h4><a name="keymgmt">Shared DES Key Management</a></h4>

<p>Each server participating in your Pubcookie authentication
infrastructure, including all login and applications servers, requires its
own encryption key. More precisely, a shared 1,024-bit DES encryption key
that's used to encrypt and decrypt the contents of various cookies. This
section describes in general terms how encryption keys are created,
stored, and distributed within Pubcokie. The next section explains how to
set up your keyserver.</p>

<p>Keys are generated and distrubted by the keyserver component, and a
master copy of each key is stored on the login server in its keystore,
<tt>{PUBCOOKIE_DIR}/keys</tt>, where each key is kept in a separate file
named after the corresponding server.</p>

<p>For example, a site with a login server and three application servers 
might have a keystore like this:</p>

<pre>
$ ls -1 /usr/local/pubcookie/keys
pubcookie_granting.key
pubcookie_granting.crt
weblogin.example.edu
my.example.edu
mail.example.edu
appserver.example.edu
</pre>

<p>New host keys are generated and issued by the keyserver upon request.  
That is, they are created when a peer server asks for one. This happens
via a SSL/TLS connection initiated by running the Pubcookie keyclient
utility on the server that needs a key. As long as there is sufficient
trust between the keyclient and the keyserver, the keyserver can issue a
key ... but only if the requesting server is authorized to receive
one.</p>

<p>New servers are authorized to request keys by their pressence in the
keystore. That is, the login server's keystore implicitly defines which
servers can be issued host keys (and therefore which servers can
participate in a site's Pubcookie infrastructure). The keyserver makes
authorization decisions based on the presence or absense of host files in
the keystore. If the keyserver finds a host file in the keystore, then
that host can request a key. This seems like a catch-22: to create a new
host key in the keystore, the key must already exist in the keystore.  
However, there is a solution.</p>

<p>Login server administrators can use the keyclient's "permit" option to
authorize new servers to request keys. For example, to authorize
<i>newapp.example.edu</i> an administrator would run this command:</p>

<pre>
$ keyclient -1 newapp.example.edu
</pre>

<p>Administrators can authorize new servers manually or automate the
process via some kind of secure web-based registration service. To control
which hosts can use the permit option, the keyserver reads the
<tt>keyserver_client_list</tt> config variable, which lists the hosts the
administrators use to permit new hosts.  This feature allows
administrators to authorize new hosts without necessarily having to log in
to the login server.</p>

<p>Finally, it's worth clarifying that the trust relationship between the
keyserver and its keyclients requires the lightweight use of Public-Key
Infrastructure. Namely, to ensure mutual authentication and a secure
communication channel for transferring shared DES keys, Pubcookie relies
on SSL certificates and the Certificate Authorities that issue them. The
keyclient and keyserver both use the <tt>ssl_ca_file</tt> and
<tt>ssl_ca_path</tt> variables to find your trusted CA root certificates,
to which you can add your own institutional CA if you have one. This is
necessary for verifying the certificates presented in the connection. The
keyclient needs to verify that it's communicating with your keyserver. And
the keyserver needs to verify a keyclient's certificate, because it's
going to use the Common Name to create a host key in the keystore.</p>

<h4><a name="keyserver">Keyserver Setup</a></h4>

<p>To set up your keyserver, first make sure you've configured
<tt>ssl_key_file</tt>, <tt>ssl_cert_file</tt>,
<tt>keyserver_client_list</tt>, and either <tt>ssl_ca_file</tt> or
<tt>ssl_ca_path</tt> depending on how you handle CA information.</p>

<p>Next setup keyserver to run from inetd or xinetd. Unfortunately, due to
subtleties in the key usage constraints, keyserver cannot run as a cgi
script underneath a login server.</p>

<p>Add a line like the following to the login server's
<tt>/etc/inetd.conf</tt>:</p>

<pre>
2222    stream  tcp     nowait  root    /usr/local/pubcookie/keyserver keyserver
</pre>

<p>Adjust the path to the keyserver binary as needed.</p>

<p>Or if you are using xinetd, create a file named <tt>keyserver</tt> in
<tt>/etc/xinetd.d</tt> with the following contents:</p>

<pre>
# description: pubcookie keyserver
service keyserver
{
	type			= UNLISTED
	protocol		= tcp
	port			= 2222
	disable			= no
	socket_type		= stream
	wait			= no
	user			= root
	group			= tty
	server			= /usr/local/pubcookie/keyserver
}
</pre>

<p>After adding the line to inetd.conf, or the file to xinetd, restart
your inetd or xinetd service.</p>

<h4><a name="keyclient">Run Keyclient for the Login Server</a></h4>

<p>To generate a host key for your login server, you need to request one
using the keyclient utility. First, authorize the login server to request
a key by using the keyclient's "permit" option. For example:</p>

<pre>
$ /usr/local/pubcookie/keyclient -1 login.example.edu
</pre>

<p>Note: the host where you initiate the keyclient "permit" must be
privileged to do so by configuration of the <tt>keyserver_client_list</tt>
variable. This is true even though the request is coming from your login
server.</p>

<p>Once the keystore has been primed using the "permit" option, run
the keyclient to generate a new DES key for the login server:</p>

<pre>
$ /usr/local/pubcookie/keyclient
</pre>

<p>Keyclient will use your config file to connect to your keyserver and
negotiate a new host key. If successful, your keystore will now have a
host key for your login server.</p>

<p>Hint: look in syslog and refer to the <a href="#debug">debugging</a>
section if you run into problems generating keys with keyserver.</p>

<h5>Generating DES keys for the application servers with keyclient</h5>

<p>When the time comes, generating host keys for application servers is
very similar. First, someone with rights to use the "permit" option must
use it to authorize the server to request a key. Then the server can
request a key, provided that the certicate presented by the keyclient
(probably the server's SSL certificate) is signed by a CA trusted by your
keyserver.</p>

<h4><a name="install">Install &amp; Test Login CGI (index.cgi)</a></h4>

<p>Once your run-time config file is set up and you've succeeded in using
keyclient to generate a DES key for your login server, you can deploy the
login cgi by copying it into your production directory from which Apache
will serve requests. (See <a href="#apacheconfig">Apache Configuration</a> 
above for some discussion of this topic.) For example:</p>

<pre>
% cp index.cgi /var/www/html
</pre>

<p>You don't need to set up an application server to test the login cgi; 
simply open your login URL in a browser and it should ask you to log in
using whichever verifier you've configured. This direct approach to
your login cgi is known as a "pinit" or "Pubcookie init" since it 
establishes a single sign-on session without authenticating you to 
a specific application.</p>

<p>Hint: look in syslog and refer to the <a href="#debug">debugging</a> 
section if you run into problems with the login cgi.</p>

<h4><a name="debug">Logging &amp; Debugging</a></h4>

<p>The login server components send messages to syslog and
can be configured to do so in greater volumes using the 
<tt>logging_level</tt> config variable, which takes the
following values:</p>

<dl compact="compact">
<dt> 0 </dt>
<dd> errors only </dd>
<dt> 1 </dt>
<dd> audit activity (auths, redirects, etc.)</dd>
<dt> 2 </dt>
<dd> some debugging messages </dd>
<dt> 3 </dt>
<dd> verbose debugging messages  </dd>
<dt> 5 </dt>
<dd> also logs HTML output </dd>
</dl>

<p>To troubleshoot problems with the keyserver and/or the login cgi,
increase the logging level in your config file to level 3, exercise
the component again, and then look in syslog for new messages.</p>

<p>Note: the basic auditing provided by logging level 1 is most 
likely sufficient for normal operation of the login server.</p>

<h4><a name="templates">Login Page Templates</a></h4>

<p>
The login cgi serves up pages based on a set of HTML templates.
By default, these templates reside in <tt>{PUBCOOKIE_DIR}/login_templates</tt>, 
but the location can be set by changing <tt>template_root</tt> in your config 
file. Generic templates are installed by default in
<tt>{PUBCOOKIE_DIR}/login_templates.default</tt>.  They should be
copied to <tt>{PUBCOOKIE_DIR}/login_templates</tt> and they will 
serve as a starting point for further localization.
</p>

<p>
Note: For reference and comparison purposes, copies of CMU and 
Washington's login templates (of some vintage) are provided in this
source distribution. See <tt>src/login_templates.cmu</tt> and 
<tt>src/login_templates.uw</tt>, respectively. Note: the syntax
for variable substitution within the templates changed during the
development of version 3.0.0. The UWash and CMU templates may be in 
the older format.
</p>

<p>
The name of each template file can be set via the
<tt>{PUBCOOKIE_DIR}/config</tt> file.  The name for each config
variable is tmpl_{default_file_name}, and they are located relative to the
<tt>template_root</tt>.  (For example, the attribute that controls the
name of the login page is <tt>tmpl_login</tt>.)

<h5>Template Files (incomplete)</h5>

<p> We are in the process of reworking the template files to make them 
more user-friendly.  The list below will be updated as work progresses.</p>

<dl compact="compact">
 <dt>login</dt>
 <dd>The Login HTML page.
  <ol>Paramters
   <li>Login Server URL</li>
   <li>The reason for the redirect (pulled from the <tt>login_*</tt>
    snippets)</li>
   <li>Hidden fields maintaining state</li>
   <li>GetCred Hidden fields</li>
  </ol>
 </dd>
 <dt>login_bad_auth</dt>
 <dd>The error displayed when the authentication failed.</dd>
 <dt>login_cache_creds_wrong</dt>
 <dd>The error displayed when the single-signon credential is not the type
  that the application is requesting.  (Rarely seen.)</dd>
 <dt>login_nolcookie</dt>
 <dd>The error displayed when the user doesn't have or has an invalid login
  cookie</dd>
 <dt>login_reauth</dt>
 <dd>The error displayed when the application has requested that the user
  reauthenticate.</dd>
 <dt>status</dt>
 <dd>The status page displaying the time remaining on the login.
  <ol>Parameters
   <li>Refresh header</li>
   <li>User name</li>
   <li>Time remaining.</li>
  </ol>
 </dd>
</dl>

<h4><a name="ok_browsers">Browser Acceptance Configuration </a></h4>

<p>
The optional <tt>{PUBCOOKIE_DIR}/ok_browsers</tt> file contains a list of browsers
accepted by the login cgi. The ok_browsers file provides the ability to 
block browsers that either have a known security flaw (i.e. don't forget 
cookies when they should) or don't work with Pubcookie. The ok_browsers 
file is optional.
</p>

<p>
Note: At the University of Washington, we've so far been too chicken to 
use the 'ok_browsers' functionality to block browsers that we suspect
don't work.  Our ok_browsers file has a single line: "Mozilla". This 
pattern matches most of the browsers we support and/or encounter; mainly 
Internet Explorer, Netscape, Mozilla, and Safari. 
</p>

<h4><a name="logout">Logout Configuration</a></h4>

<p>The login cgi automatically handles logout requests from applications.
This functionality is built in; no configuration is necessary on the login 
server. Through additional configuration you can create a separate logout
URL on your login server and also tailor some of the logout text for your
favoriate applications.</p>

<p>Note: Pubcookie 3.0 does not support "global" logout: logout of all
applications, all cookies, all at once. Rather, it supports per-application
logout, plus the ability to logout of the login server, all separately.
Therefore, users must still be educated and warned to exit their browser 
in order to get logged out of everything at once.</p>

<h5>Configuring a Logout URI</h5>

<p>If you want to provide a URL where users can go directly to clear their 
single sign-on session (pubcookie login cookie), it can be created with 
the logout_prog config variable and a Unix symbolic link. Here's an example.</p>

<p>Suppose the login cgi has been installed in the web server's root directory
(e.g. https://weblogin.example.edu) and you want to create a logout URI of "/logout/"
just below that (e.g. https://weblogin.example.edu/logout/). First, you would want
to create the subdirectory and symbolic link to your login cgi:

<pre>
$ cd /var/www/html
$ ls
index.cgi     images/
$ mkdir logout
$ cd logout
$ ln -s ../index.cgi index.cgi
</pre>

<p>Now any request to /logout/ on the server will map to your login cgi.
(editor: Is there a better way to do this in httpd.conf instead?) All that's left
is adding the appropriate <tt>logout_prog</tt> variable to your Pubcookie config file:</p>

<pre>
logout_prog: /logout/index.cgi
</pre>

<h5>Customizing Logout Responses For Special Apps </h5>

<p>The login cgi builds logout response pages from several templates. One template, 
<tt>logout_app</tt>, which is the most specific to each application, can be overridden 
on a per-application basis, as configured and identified by the originating server 
name and application id. It requires one <tt>app_logout_string</tt> config file variable
for each application, where the server name and id are tacked on using dashes. For example:

<pre>
# custom logout msgs
app_logout_string-appserver.example.edu-testapp: &lt;font size="+1"&gt;Testapp logout worked just fine.&lt;/font&gt;
app_logout_string-webmail.example.edu-webmail: &lt;font size="+1"&gt;Webmail Logout Successful!&lt;/font&gt;
</pre>

<p>Note: Since the login cgi reads the config file and its HTML templates on each request, 
there's no need to recompile the login cgi in order to modify response text.</p>

<h4><a name="kiosk">Kiosk Configuration</a></h4>

<p>Use the <tt>kiosk</tt> variable to apply a site policy for reduced
single sign-on duration for identified kiosks. The login cgi supports 
matching by user-agent string, remote IP address, or IP address ranges.
For example:</p>

<pre>
kiosk:   20m Safari/85.6 \
         15m Safari \
         10m ExampleKiosk 140.142.14.39 140.142.21.* \
         1h  140.142.15.10-200
</pre>

<p>This sets a curiously elaborate, but nonetheless illustrative,
kiosk policy: a 20-minute SSO duration for Safari 85.6, a 15-minute 
SSO for all other versions of Safari, a 10-minute SSO to remote browsers
with "ExampleKiosk" in the user-agent string as well as to the remote IP
address 140.142.14.39 and the 140.142.21 subdomain, and a one-hour 
SSO duration for IP addresses in the range 140.142.15.10-200.</p>

<p>Matching by user-agent string is particularly useful for 
applying reduced SSO to managed kiosks that have a locally
customized user-agent string such as:</p>

<pre>
User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; ExampleKiosk; Windows NT 5.0)
</pre>

<p>How to customize user-agent strings is beyond the scope of this guide,
but resources and tools, such as the <a href="http://www.microsoft.com/windows/ieak/default.asp">Internet 
Explorer Administration Kit</a>, do exist to help with this task.</p>

<h4><a name="krb5">Kerberos 5 Verifier Configuration</a></h4>

<p>To build the login cgi with support for the Kerberos 5 verifier,
run the configure script with the Kerberos option enabled:</p>

<pre>
./configure --enable-login --disable-apache --enable-krb5
</pre>

<p>If needed, the configure script has other options for adjusting the
location of the Kerberos header files and libraries.</p>

<p>To configure the login cgi to use the Kerberos verifier, edit your
pubcookie config file and set <tt>basic_verifier</tt> to
<tt>kerberos_v5</tt>. Additionally, two other <a href="config.html">config
file variables</a> control the Kerberos 5 verifier:
<tt>kerberos5_service_name</tt> and <tt>kerberos5_keytab</tt>. For 
example:</p>

<pre>
# kerberos verifier config
basic_verifier: kerberos_v5
kerberos5_service_name: pubcookie
kerberos5_keytab: /usr/local/pubcookie/keys/pubcookie.keytab
</pre>

<p>To authenticate responses from your Kerberos server, the login server and
Kerberos server must share a service key. You can use an existing service key
or generate a new one with the help of your Kerberos administrator. Keep in
mind that the keytab file that contains your service key must be readable by
the login cgi. Since the login cgi will most likely run as a non-root user,
it's recommended that you use a service key other than the "host" service key
typically stored in <tt>/etc/krb5.keytab</tt>.</p>

<p>Similar to user keys, service keys have a principal of the form
<tt>&lt;service_name&gt;/&lt;hostname&gt;@&lt;realm&gt;</tt>. The hostname is
the fully qualified hostname for your login server, and the realm is the
Kerberos realm. But the service name is what counts most to the Kerberos 5
verifier. Your service name can be set with the
<tt>kerberos5_service_name</tt> variable.</p>

<p>Contact your local Kerberos domain administrator if you need help creating a
service key, generating a keytab file, or otherwise configuring Kerberos
(e.g. <tt>/etc/krb5.conf</tt>) on your login server.</p>

<h4><a name="upgrading">Upgrading</a></h4>

<h5>Upgrading from pre-3.0 pubcookie</h5>

<ul>
<li>Maintaining DES key compatibility from hashed IP addresses

<p>
If you have an exisiting pubcookie installation using a shared DES key
with hashed IP addresses, you can upgrade your login server without 
generating new keys on every application server.
</p>

<p>
On the login server, in the .../pubcookie/keys/ directory, make a copy of
the master DES key (before hashing it to any IP address) for each application
server, named with the full hostname of the server.</p>

<p>
For example, create <tt>.../pubcookie/keys/oldappserver.example.edu</tt>
containing the original DES keyfile.</p>

<p>
The login server will use this key to encrypt data going to that application
server, and the application server can continue to use it's key (XOR'd with
it's IP address) to decrypt the data.</p>

<p>
During the application server's next scheduled downtime, you can
create a new unique DES key for that application, as in the <a
href="#keymgt">Key Management &amp; Setup</a> section above.</p></li>

</ul>

<h4><a name="advconfig">Advanced Configuration</a></h4>

<h5>Redundant login servers</h5>

<h5>Redundant application hosts</h5>

<p>
Sites frequently want several hosts configured identically to provide
redundancy (either for performance or stability). In this section,
we're assuming that you have a set of machines with an identical SSL
certificate and key on them.</p>

<p>For instance, an institution might have 15 webmail servers named
<tt>webmail1.example.edu</tt> through <tt>webmail15.example.edu</tt>
with 15 unique IP addresses. All of them are equipped with a
<tt>webmail.example.edu</tt> certificate and are behind a Cisco Load
Director which controls the IP address for
<tt>webmail.example.edu</tt>.</p>

<p>Use <tt>keyclient</tt> on <tt>webmail1.example.edu</tt> to generate
a <tt>webmail.example.edu</tt> DES key. Use <tt>keyclient -d</tt> on
all other webmail machines (<tt>webmail2.example.edu</tt>, etc.) to
download an identical application key to the remaining servers.</p>

<h4><a name="security">Security Considerations</a></h4>

<h5>Login server security</h5>

<p>Don't run anything else on it: anyone who can add content
to the login server can steal all cookies.</p>

<h5>Application server security</h5>

<h5>Handling secrets</h5>

<h5>Other stuff</h5>

<h4><a name="oldtools">Old Tools That Might Be Handy for Debugging</a></h4>

<p>
<tt>pbc_create</tt> creates a pubcookie cookie, convenient for
creating cookies ad hoc.  Arguments come in via stdin and the cookie
is put out on stdout.  Args are space delimited, and in order: user
appsrvid appid type creds serial crypt_file cert_key_file.  Anything
too big is just truncated, no support for defaults or anything like
that.  See src for details.</p>

<p>
<tt>pbc_verify</tt> decrypts/verifies/displays pubcookie cookies,
convenient for 'unbundling' a cookie and seeing what's inside.  The
arguments come in on the command line, the cookie comes in on stdid,
and the contents are dumped to stdout.  The required argument is
cookie_type and the optional arguments are encryption_key and
cert_file.</p>

<p>
As an example you can use these two programs to do things like:</p>

<pre>
# echo "willey appsrvid appid 1 2 23 \
    /usr/local/pubcookie/c_key /usr/local/pubcookie/test.key" | \
    ./pbc_create | \
    ./pbc_verify 1 /usr/local/pubcookie/c_key /usr/local/pubcookie/test.crt
</pre>

<p>and get something like</p>

<pre>
user: willey
version: a5
type: 1
creds: 2
serial: 23
appsrvid: appsrvid
appid: appid
create_ts: 1006986719
last_ts: 1006986719
</pre>

<hr>
<p>
Copyright 1999-2004, University of Washington.  All rights reserved.<br>
See doc/LICENSE.txt for terms of use.
</p>
<pre>
$Id: install-login.html,v 1.16 2004-02-05 22:54:24 dors Exp $
</pre>
</body>

</html>
